
import os
import gzip
import argparse
import couchdb
from datetime import datetime
from collections import Counter

class BarcodeExtractor():
    """Parse a FastQ-file and extract the barcode assumed to be at the 
       given offset and of specified length
    """
    
    def __init__(self,  fqfile, pre_casava=False, offset=101, length=6):
        fh = open(fqfile)
        if os.path.splitext(fqfile)[1] == ".gz":
            self.fh = gzip.GzipFile(fileobj=fh)
        else:
            self.fh = fh
        self.start = offset
        self.end = offset+length
        self.pre_casava = pre_casava
        self.total = 0
        self._next = self.setup_next(self.start, self.end)
        
    def __iter__(self):
        return self
    def next(self):
        return self._next(self)
    
    def setup_next(self, start, end):
        """Return the function to extract the barcode
        """
        if self.pre_casava:
            def next_pre_casava(self):
                _, seq, _, _ = [self.fh.next() for i in xrange(4)]
                self.total += 1
                return seq[start:end]
            return next_pre_casava
        
        def next_casava(self):
            header, _, _, _ = [self.fh.next() for i in xrange(4)]
            self.total += 1
            return header.strip().rsplit(":",1)[1]
        return next_casava

def extract_barcodes(fqfile, nindex=25, pre_casava=False, offset=101, bclen=6):
    """Parse the fastq file and extract barcodes. Return a dict structure suitable for upload to StatusDB
    """
    
    bcx = BarcodeExtractor(fqfile, pre_casava, offset, bclen)
    c = Counter(bcx)
    counts = {'Index': [],
              'Counts': []}
    
    for bc, count in c.most_common(nindex):
        counts['Index'].append(bc)
        counts['Counts'].append(count)
        
    return counts

def upload_undetermined(db, fcdir, lane, fqfile, nindex, pre_casava, offset, bclen):
    """Extract and upload indexes
    """
    date, instrument, runno, fcid = os.path.basename(os.path.abspath(fcdir)).split("_")
    
    entry = {'flowcell_dir': fcdir,
             'flowcell_date': date,
             'instrument': instrument,
             'run_number': runno,
             'flowcell_position': fcid[0],
             'flowcell_id': fcid[1:],
             'file_name': fqfile,
             'entity_type': 'LaneUndeterminedIndices',
             'lane': lane,
             'creation_time': datetime.utcnow().isoformat() + "Z",
             'modification_time': datetime.utcnow().isoformat() + "Z"}
    
    indices = extract_barcodes(fqfile, nindex, pre_casava, offset, bclen)
    entry['undetermined_indices'] = indices
    db.save(entry)

def main():
    
    parser = argparse.ArgumentParser(description="""Count undetermined indices from fastq file and upload to StatusDB""")

    parser.add_argument('-o','--offset', action='store', default=101, 
                        help="The offset into the read where the barcode sequence starts. Only used for Casava 1.7- files.")
    parser.add_argument('-b','--barcode-length', dest='barcode_length', action='store', default=6, 
                        help="The length of the barcode sequence. Only used for Casava 1.7- files.")
    parser.add_argument('-n','--nindex', dest='nindex', action='store', default=25, 
                        help="The number of top indexes to report.")
    parser.add_argument('--host', dest='host', action='store', required=True,
                        help="The adress of the couchdb instance")
    parser.add_argument('--port', dest='port', action='store', default=5984,
                        help="The port of the couchdb instance")
    parser.add_argument('--db', dest='db', action='store', required=True,
                        help="The database for the couchdb instance")
    parser.add_argument('--user', dest='user', action='store', required=True,
                        help="The user for the couchdb instance")
    parser.add_argument('--pass', dest='pwd', action='store', required=True,
                        help="The password for the couchdb instance")
    parser.add_argument('--1.7', dest='pre_casava', action='store_true', default=False, 
                        help="The sequence file was generated by Casava 1.7-.")
    parser.add_argument('fcdir', action='store', default=None, 
                        help="The name of the flowcell directory.")
    parser.add_argument('lane', action='store', default=None, 
                        help="The lane that the fastq file represents.")
    parser.add_argument('infile', action='store',
                        help="The input FastQ file to process. Can be gzip compressed")
    
    
    args = parser.parse_args()
    couch = couchdb.Server("http://{}:{}@{}:{}".format(args.user,args.pwd,args.host,args.port))
    db = couch[args.db]
    
    upload_undetermined(db, args.fcdir, args.lane, args.infile, args.nindex, args.pre_casava, args.offset, args.barcode_length)
    
if __name__ == "__main__":
    main()
 
### Tests ###

import unittest
import generate_test_data as td
import shutil
import tempfile
import random
import scilifelab.utils.fastq_utils as fu

class TestBarcodeExtractor(unittest.TestCase):
    """Test class for the functionality
    """
    
    def setUp(self):
        """Set up a test fastq file
        """
        self.rootdir = tempfile.mkdtemp(prefix="test_extract_pre_casava_index_")
        
        # Set up a fastq file
        fd, fqfile = tempfile.mkstemp(dir=self.rootdir,suffix=".fastq.gz")
        os.close(fd)
        fqw = fu.FastQWriter(fqfile)
        
        # Generate a set of indexes
        seqlen = 101
        bclen = 6
        barcodes = dict(zip([td.generate_barcode(bclen) for i in xrange(100)],[random.randint(10,100) for i in xrange(100)]))
        
        # Generate fastq records and append the barcode
        for barcode, nseqs in barcodes.items():
            for i in xrange(nseqs):
                rec = td.generate_fastq_record(**{'index': barcode, 'sequence_length': seqlen})
                rec[1] = "{}{}A".format(rec[1],barcode)
                fqw.write(rec)
        fqw.close()
        
        self.sequence_length = seqlen
        self.barcode_length = bclen
        self.barcodes = barcodes
        self.fastq_file = fqfile
        
    def tearDown(self):
        shutil.rmtree(self.rootdir)
        
    def test_pre_casava_barcode_extractor(self):
        """Test BarcodeExtractor for Casava 1.7 files
        """
        
        # Create a barcode extractor object
        bcx = BarcodeExtractor(self.fastq_file,True,self.sequence_length,self.barcode_length)
        
        # Create a counter from the extracted barcodes 
        obs_cnt = Counter(bcx).most_common()
        # Cretae a counter from the true barcodes
        exp_cnt = Counter(self.barcodes).most_common()

        # Assert the observerd and expected barcode counts are the same
        self.assertListEqual(sorted(obs_cnt), sorted(exp_cnt),
                              "Extracted and expected barcode counts don't match")


    def test_casava_barcode_extractor(self):
        """Test BarcodeExtractor for Casava 1.8+ files
        """
        
        # Create a barcode extractor object
        bcx = BarcodeExtractor(self.fastq_file)
        
        # Create a counter from the extracted barcodes  
        obs_cnt = Counter(bcx).most_common()
        # Cretae a counter from the true barcodes
        exp_cnt = Counter(self.barcodes).most_common()

        # Assert the observerd and expected barcode counts are the same
        self.assertListEqual(sorted(obs_cnt), sorted(exp_cnt),
                              "Extracted and expected barcode counts don't match")
        
    def test_extract_barcodes(self):
        """Extract barcodes
        """
        nindex = 25
        obs_dict = extract_barcodes(self.fastq_file,nindex)
        exp_dict = {'Index': [],
                    'Counts': []}
        exp_cnt = Counter(self.barcodes).most_common(nindex)
        for bc, count in exp_cnt:
            exp_dict['Index'].append(bc)
            exp_dict['Counts'].append(count)
        # Assert the observerd and expected barcode counts are the same
        self.assertListEqual(sorted(obs_dict['Index']), sorted(exp_dict['Index']),
                             "Extracted and expected barcodes don't match")
        self.assertListEqual(obs_dict['Counts'], exp_dict['Counts'],
                             "Extracted and expected barcode counts don't match")
        
